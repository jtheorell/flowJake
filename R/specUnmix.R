#' Plotting all variables against a single variable
#'
#'
#' This function is useful both when setting appropriate gates and when the adjustments of the compensation are done
#' @importFrom grDevices col2rgb colorRampPalette densCols dev.off png
#' @importFrom graphics mtext par plot title
#' @param rawData This can be either be a data frame, a FlowFrame or a FlowSet.
#' @param specMat Here, the matrix generated by the secMatCalc function is added, that is used for the
#' @return The unmixed data. It will be returned in the format it was imported as.
#'
#' #Load some uncompensated data
#' data(fullPanel)
#'
#' #Select the rows that should be compensated
#' fluoExprs <- fullPanel[,grepl("[VBRY]", colnames(fullPanel))]
#' #Load the spectral unmixing matrix generated with controls from the same experiment. These can be generated using the specMatCalc function.
#' data(specMat)
#'
#' #And now, just run the function!
#' dataComp <- specUnmix(fluoExprs, specMat)
#'
#' @export specUnmix
specUnmix <- function(rawData, specMat){

  # Make the least squares fit based on the raw, uncompensated data.
  ls_corr <- lsfit(x=t(specMat), y=t(rawData), intercept=FALSE)

  #Export the compensated portion of the least squares result.
  ls_corr_coeff <- data.frame(t(ls_corr$coefficients))
  colnames(ls_corr_coeff) <- row.names(specMat)

  return(ls_corr_coeff)
}
